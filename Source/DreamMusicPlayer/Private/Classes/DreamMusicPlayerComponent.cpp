// Copyright Â© Dream Moon Studio . Dream Moon All rights reserved


#include "Classes/DreamMusicPlayerComponent.h"

#include "ConstantQNRT.h"
#include "DreamMusicPlayerBlueprint.h"
#include "DreamMusicPlayerDebugLog.h"
#include "Algo/RandomShuffle.h"
#include "Containers/Array.h"
#include "DreamMusicPlayerLog.h"
#include "LoudnessNRT.h"
#include "Classes/DreamLyricParser.h"
#include "Classes/DreamMusicData.h"
#include "Classes/DreamMusicPlayerLyricTools.h"
#include "Kismet/KismetMathLibrary.h"
#include "AsyncAction/DreamAsyncAction_KMeansTexture.h"

UDreamMusicPlayerComponent::UDreamMusicPlayerComponent()
{
	PrimaryComponentTick.bCanEverTick = true;
}

void UDreamMusicPlayerComponent::BeginPlay()
{
	// Create audio components with better configuration
	SubAudioComponentA = NewObject<UAudioComponent>(GetOwner(), TEXT("MusicPlayerAudioComponentA"));
	if (SubAudioComponentA)
	{
		SubAudioComponentA->SetupAttachment(GetOwner()->GetRootComponent());
		SubAudioComponentA->bAutoActivate = false; // Prevent auto-activation
		if (SoundClass)
		{
			SubAudioComponentA->SoundClassOverride = SoundClass;
		}
		SubAudioComponentA->RegisterComponent();
	}

	SubAudioComponentB = NewObject<UAudioComponent>(GetOwner(), TEXT("MusicPlayerAudioComponentB"));
	if (SubAudioComponentB)
	{
		SubAudioComponentB->SetupAttachment(GetOwner()->GetRootComponent());
		SubAudioComponentB->bAutoActivate = false; // Prevent auto-activation
		if (SoundClass)
		{
			SubAudioComponentB->SoundClassOverride = SoundClass;
		}
		SubAudioComponentB->RegisterComponent();
	}

	if (SongList)
	{
		InitializeMusicList();
	}

	Super::BeginPlay();
}

void UDreamMusicPlayerComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	// Stop any playing music
	if (bIsPlaying)
	{
		EndMusic(true);
	}

	// Clean up timers
	if (GWorld && GWorld->GetTimerManager().TimerExists(StopTimerHandle))
	{
		GWorld->GetTimerManager().ClearTimer(StopTimerHandle);
	}

	// Cancel any pending async operations
	if (CurrentKMeansTask && CurrentKMeansTask->IsValidLowLevel())
	{
		CurrentKMeansTask->Cancel();
		CurrentKMeansTask = nullptr;
	}

	// Clean up audio components
	if (SubAudioComponentA && SubAudioComponentA->IsValidLowLevel())
	{
		SubAudioComponentA->Stop();
	}
	if (SubAudioComponentB && SubAudioComponentB->IsValidLowLevel())
	{
		SubAudioComponentB->Stop();
	}

	Super::EndPlay(EndPlayReason);
}

void UDreamMusicPlayerComponent::TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	if (bIsPlaying && !bIsPaused)
	{
		MusicTick(DeltaTime);
	}
}

void UDreamMusicPlayerComponent::SetPlayMode(EDreamMusicPlayerPlayMode InPlayMode)
{
	PlayMode = InPlayMode;
	OnPlayModeChanged.Broadcast(PlayMode);
}

void UDreamMusicPlayerComponent::InitializeLyricList()
{
	if (!CurrentMusicData.IsVaild())
	{
		DMP_LOG(Error, TEXT("CurrentMusicData is Not Valid"));
		return;
	}
	DMP_LOG(Log, TEXT("InitializeLyricList - Begin"));
	CurrentMusicLyricList.Empty();

	FDreamLyricParser Parser(FDreamMusicPlayerLyricTools::GetLyricFilePath(CurrentMusicData.Data.LyricFileName),
	                         CurrentMusicData.Data.LyricParseFileType,
	                         CurrentMusicData.Data.LyricParseLineType,
	                         CurrentMusicData.Data.LrcLyricType);

	CurrentMusicLyricList = Parser.GetLyrics();

	OnLyricListChanged.Broadcast(CurrentMusicLyricList);
	DMP_LOG(Log, TEXT("InitializeLyricList Count : %02d - End"), CurrentMusicLyricList.Num());
}

void UDreamMusicPlayerComponent::InitializeMusicList()
{
	DMP_LOG(Log, TEXT("InitializeMusicList - Begin"));
	TArray<FDreamMusicPlayerSongList*> BufferList;
	MusicDataList.Empty();
	SongList->GetAllRows<FDreamMusicPlayerSongList>("", BufferList);
	for (auto Element : BufferList)
	{
		if (Element)
		{
			MusicDataList.Add(Element->MusicData->Data);
		}
	}
	OnMusicDataListChanged.Broadcast(MusicDataList);
	DMP_LOG(Log, TEXT("InitializeMusicList Count : %02d - End"), MusicDataList.Num());
}

void UDreamMusicPlayerComponent::InitializeMusicListWithSongTable(UDataTable* Table)
{
	SongList = Table;
	InitializeMusicList();
}

void UDreamMusicPlayerComponent::InitializeMusicListWithDataArray(TArray<FDreamMusicDataStruct> InData)
{
	MusicDataList.Empty();
	MusicDataList = InData;
	OnMusicDataListChanged.Broadcast(MusicDataList);
}

void UDreamMusicPlayerComponent::PlayMusic(EDreamMusicPlayerPlayMode InPlayMode)
{
	PlayMode = InPlayMode;
	if (PlayMode == EDreamMusicPlayerPlayMode::EDMPPS_Random)
	{
		Algo::RandomShuffle(MusicDataList);
	}

	if (bIsPlaying)
	{
		EndMusic();
	}

	SetMusicData(MusicDataList[0]);
	StartMusic();
}

void UDreamMusicPlayerComponent::PlayNextMusic()
{
	if (MusicDataList.IsEmpty())
	{
		DMP_LOG(Warning, TEXT("Music List Is Empty !!!"));
		return;
	}

	if (bIsPlaying)
	{
		EndMusic(true);
	}

	SetMusicData(GetNextMusicData(CurrentMusicData));
	StartMusic();
}

void UDreamMusicPlayerComponent::PlayLastMusic()
{
	if (MusicDataList.IsEmpty())
	{
		DMP_LOG(Warning, TEXT("Music List Is Empty !!!"));
		return;
	}

	if (bIsPlaying)
	{
		EndMusic(true);
	}

	SetMusicData(GetLastMusicData(CurrentMusicData));
	StartMusic();
}

void UDreamMusicPlayerComponent::PlayMusicWithLyric(FDreamMusicLyric InLyric)
{
	if (CurrentMusicLyricList.Contains(InLyric))
	{
		float Time = InLyric.StartTimestamp.ToSeconds();
		Time = UKismetMathLibrary::NormalizeToRange(Time, 0.0f, CurrentMusicDuration);
		SetMusicPercent(Time);
	}
	else
	{
		DMP_LOG(Warning, TEXT("%hs Lyric Not Found !!!"), __FUNCTION__)
	}
}

void UDreamMusicPlayerComponent::SetPauseMusic(bool bInPause)
{
	if (bInPause)
	{
		PauseMusic();
	}
	else
	{
		UnPauseMusic();
	}
}

void UDreamMusicPlayerComponent::TogglePauseMusic()
{
	if (bIsPaused)
	{
		UnPauseMusic();
	}
	else
	{
		PauseMusic();
	}
}

void UDreamMusicPlayerComponent::PlayMusicFromMusicData(FDreamMusicDataStruct InData)
{
	PlayMode = EDreamMusicPlayerPlayMode::EDMPPS_Loop;
	SetMusicData(InData);
	StartMusic();
}

void UDreamMusicPlayerComponent::PlayMusicFromMusicDataAsset(UDreamMusicData* InData)
{
	PlayMode = EDreamMusicPlayerPlayMode::EDMPPS_Loop;
	SetMusicData(InData->Data);
	StartMusic();
}

FDreamMusicDataStruct UDreamMusicPlayerComponent::GetNextMusicData(FDreamMusicDataStruct InData)
{
	if (PlayMode == EDreamMusicPlayerPlayMode::EDMPPS_Loop)
	{
		return CurrentMusicData.IsVaild() ? CurrentMusicData : InData;
	}
	if (MusicDataList.Contains(InData))
	{
		return MusicDataList[(MusicDataList.Find(InData) + 1) > MusicDataList.Num() - 1
			                     ? 0
			                     : MusicDataList.Find(InData) + 1];
	}
	else
	{
		return MusicDataList[0];
	}
}

FDreamMusicDataStruct UDreamMusicPlayerComponent::GetLastMusicData(FDreamMusicDataStruct InData)
{
	if (PlayMode == EDreamMusicPlayerPlayMode::EDMPPS_Loop)
	{
		return CurrentMusicData.IsVaild() ? CurrentMusicData : InData;
	}
	return MusicDataList[(MusicDataList.Find(InData) - 1 < 0)
		                     ? MusicDataList.Num() - 1
		                     : MusicDataList.Find(InData) - 1];
}

void UDreamMusicPlayerComponent::GetAudioNrtData(bool bConstantReverse, TArray<float>& ConstantNrtL, TArray<float>& ConstantNrtR,
                                                 TArray<float>& ConstantNrtAverage,
                                                 float& OutLoudnessValue)
{
	ConstantNrtL = ConstantQDataL;
	ConstantNrtR = ConstantQDataR;
	TArray<float> ConstantQData, ConstantQDataAverage;
	if (bConstantReverse)
	{
		ConstantQData.Append(ConstantQDataR);
		ConstantQData.Append(ConstantQDataL);
	}
	else
	{
		ConstantQData.Append(ConstantQDataL);
		ConstantQData.Append(ConstantQDataR);
	}

	for (int i = 0; i < ConstantQData.Num() / 2; ++i)
	{
		ConstantQDataAverage.Add((ConstantQData[i] + ConstantQData[ConstantQData.Num() - i - 1]) / 2);
	}
	ConstantNrtAverage = ConstantQDataAverage;
	OutLoudnessValue = LoudnessValue;
}

UAudioComponent* UDreamMusicPlayerComponent::GetActiveAudioComponent() const
{
	UAudioComponent* Component = CurrentActiveAudioComponent ? SubAudioComponentB : SubAudioComponentA;
	return IsAudioComponentReady(Component) ? Component : nullptr;
}


UAudioComponent* UDreamMusicPlayerComponent::GetLastActiveAudioComponent() const
{
	UAudioComponent* Component = CurrentActiveAudioComponent ? SubAudioComponentA : SubAudioComponentB;
	return IsAudioComponentReady(Component) ? Component : nullptr;
}

FDreamMusicLyricProgress UDreamMusicPlayerComponent::GetCurrentLyricWordProgress(const FDreamMusicLyricTimestamp& InTimestamp) const
{
	return CalculateWordProgress(InTimestamp);
}

FDreamMusicLyricProgress UDreamMusicPlayerComponent::GetCurrentRomanizationProgress(const FDreamMusicLyricTimestamp& InTimestamp) const
{
	return CalculateWordProgress(InTimestamp, true);
}

FDreamMusicLyricProgress UDreamMusicPlayerComponent::GetCurrentLyricLineProgress(const FDreamMusicLyricTimestamp& InTimestamp) const
{
	return CalculateLineProgress(InTimestamp);
}

void UDreamMusicPlayerComponent::ExtractCoverThemeColors(int32 ClusterCount, int32 MaxIterations)
{
	if (!Cover || !Cover->IsValidLowLevel())
	{
		DMP_LOG(Warning, TEXT("No valid cover image available for theme color extraction"));
		OnThemeColorChanged.Broadcast(TArray<FKMeansColorCluster>(), false);
		return;
	}

	// Clean up existing task more safely
	if (CurrentKMeansTask)
	{
		if (CurrentKMeansTask->IsValidLowLevel() && !CurrentKMeansTask->IsCompletedOrCancelled())
		{
			DMP_LOG(Log, TEXT("Cancelling previous K-Means task before starting new one"));
			CurrentKMeansTask->Cancel();
		}
		CurrentKMeansTask = nullptr;
	}

	ExtractTextureThemeColors(Cover, ClusterCount, MaxIterations);
}


void UDreamMusicPlayerComponent::ExtractTextureThemeColors(UTexture2D* Texture, int32 ClusterCount, int32 MaxIterations)
{
	if (!Texture || !Texture->IsValidLowLevel())
	{
		DMP_LOG(Warning, TEXT("Invalid texture for theme color extraction - Texture is null or invalid"));
		OnThemeColorChanged.Broadcast(TArray<FKMeansColorCluster>(), false);
		return;
	}

	// Enhanced texture validation
	const FTexturePlatformData* PlatformData = Texture->GetPlatformData();
	if (!PlatformData || PlatformData->Mips.Num() == 0)
	{
		DMP_LOG(Warning, TEXT("Invalid texture for theme color extraction - No platform data or mips"));
		OnThemeColorChanged.Broadcast(TArray<FKMeansColorCluster>(), false);
		return;
	}

	const FTexture2DMipMap& MipMap = PlatformData->Mips[0];
	if (MipMap.BulkData.GetBulkDataSize() == 0)
	{
		DMP_LOG(Warning, TEXT("Invalid texture for theme color extraction - Empty bulk data"));
		OnThemeColorChanged.Broadcast(TArray<FKMeansColorCluster>(), false);
		return;
	}

	// Clean up existing task safely
	if (CurrentKMeansTask)
	{
		if (CurrentKMeansTask->IsValidLowLevel() && !CurrentKMeansTask->IsCompletedOrCancelled())
		{
			DMP_LOG(Log, TEXT("Cancelling existing K-Means task"));
			CurrentKMeansTask->Cancel();
		}
		CurrentKMeansTask = nullptr;
	}

	// Create new task with clamped parameters
	CurrentKMeansTask = UDreamAsyncAction_KMeansTexture::KMeansTextureAnalysis(
		Texture,
		FMath::Clamp(ClusterCount, 1, CoverThemeColorCount),
		FMath::Clamp(MaxIterations, 1, MaxIterationsCount),
		FMath::Clamp(SampleRate, 0.1f, 1.0f),
		bIgnoreTransparent,
		FMath::Clamp(AlphaThreshold, 0.0f, 1.0f)
	);

	if (CurrentKMeansTask && CurrentKMeansTask->IsValidLowLevel())
	{
		DMP_LOG(Log, TEXT("Creating K-Means analysis task for texture: %s (Size: %dx%d, Format: %d)"),
		        *Texture->GetName(), Texture->GetSizeX(), Texture->GetSizeY(), (int)Texture->GetPixelFormat());

		CurrentKMeansTask->OnCompleted.AddDynamic(this, &UDreamMusicPlayerComponent::OnThemeColorsExtracted);
		CurrentKMeansTask->Activate();

		DMP_LOG(Log, TEXT("Started theme color extraction for texture: %s"), *Texture->GetName());
	}
	else
	{
		DMP_LOG(Warning, TEXT("Failed to create K-Means analysis task for texture: %s"), *Texture->GetName());
		OnThemeColorChanged.Broadcast(TArray<FKMeansColorCluster>(), false);
	}
}

bool UDreamMusicPlayerComponent::IsAudioComponentReady(UAudioComponent* Component) const
{
	return Component &&
		Component->IsValidLowLevel() &&
		Component->IsRegistered() &&
		!Component->HasAnyFlags(RF_BeginDestroyed | RF_FinishDestroyed);
}


float UDreamMusicPlayerComponent::GetAccuratePlayTime() const
{
	if (!bIsPlaying || bIsPaused)
	{
		return CurrentDuration;
	}

	// å¦æååè¿è¡äº Seekï¼ä½¿ç¨ Seek ä½ç½®ä½ä¸ºåºå
	if (bJustSeeked)
	{
		return LastSeekPosition;
	}

	// ä½¿ç¨ä¸çæ¶é´æ¥è®¡ç®æ´ç²¾ç¡®çæ­æ¾æ¶é´
	if (MusicStartWorldTime > 0.0)
	{
		double CurrentWorldTime = FPlatformTime::Seconds();
		float ElapsedTime = static_cast<float>(CurrentWorldTime - MusicStartWorldTime);
		float CalculatedTime = LastSeekPosition + ElapsedTime;

		// ç¡®ä¿æ¶é´ä¸ä¼è¶åºé³ä¹é¿åº¦
		return FMath::Clamp(CalculatedTime, 0.0f, CurrentMusicDuration);
	}

	// éçº§å°å½åè®¡ç®æ¹æ³
	return CurrentDuration;
}

void UDreamMusicPlayerComponent::UpdateAudioAnalysisData()
{
	if (ConstantQ && ConstantQ->IsValidLowLevel())
	{
		ConstantQ->GetNormalizedChannelConstantQAtTime(CurrentDuration, 0, ConstantQDataL);
		ConstantQ->GetNormalizedChannelConstantQAtTime(CurrentDuration, 1, ConstantQDataR);
	}

	if (Loudness && Loudness->IsValidLowLevel())
	{
		Loudness->GetNormalizedLoudnessAtTime(CurrentDuration, LoudnessValue);
	}
}

void UDreamMusicPlayerComponent::BuildWordDurationCache(bool bUseRoma) const
{
	if (bCacheValid && bLastUseRoma == bUseRoma)
	{
		return;
	}

	const TArray<FDreamMusicLyricWord>& Words = bUseRoma ? CurrentLyric.RomanizationWordTimings : CurrentLyric.WordTimings;
        
	WordDurationPrefixSum.Empty();
	WordDurationPrefixSum.Reserve(Words.Num());
        
	int32 CumulativeDuration = 0;
	for (const FDreamMusicLyricWord& Word : Words)
	{
		int32 WordDuration = Word.EndTimestamp.ToMilliseconds() - Word.StartTimestamp.ToMilliseconds();
		CumulativeDuration += WordDuration;
		WordDurationPrefixSum.Add(CumulativeDuration);
	}
        
	bCacheValid = true;
	bLastUseRoma = bUseRoma;
}

void UDreamMusicPlayerComponent::OnThemeColorsExtracted(const TArray<FKMeansColorCluster>& ColorClusters, bool bSuccess)
{
	// Safely clear the current task reference
	UDreamAsyncAction_KMeansTexture* CompletedTask = CurrentKMeansTask;
	CurrentKMeansTask = nullptr;

	if (bSuccess && ColorClusters.Num() > 0)
	{
		DMP_LOG(Log, TEXT("Theme color extraction completed successfully. Found %d colors"), ColorClusters.Num());

		// Log extracted colors for debugging
		for (int32 i = 0; i < ColorClusters.Num(); ++i)
		{
			const FKMeansColorCluster& Cluster = ColorClusters[i];
			DMP_LOG(Log, TEXT("Color %d: R=%.3f G=%.3f B=%.3f Weight=%.3f PixelCount=%d"),
			        i, Cluster.Color.R, Cluster.Color.G, Cluster.Color.B, Cluster.Weight, Cluster.PixelCount);
		}
	}
	else
	{
		// Enhanced error reporting
		if (!bSuccess)
		{
			DMP_LOG(Warning, TEXT("Theme color extraction failed or was cancelled"));
		}
		else
		{
			DMP_LOG(Warning, TEXT("Theme color extraction found no colors"));
		}

		// Additional debugging info if task is available
		if (CompletedTask && CompletedTask->IsValidLowLevel())
		{
			DMP_LOG(Warning, TEXT("Task details - Texture: %s, SampledPixels: %d"),
			        CompletedTask->GetTargetTexture() ? *CompletedTask->GetTargetTexture()->GetName() : TEXT("NULL"),
			        CompletedTask->GetSamplePixelNum());
		}
	}

	OnThemeColorChanged.Broadcast(ColorClusters, bSuccess);
}

FDreamMusicLyricProgress UDreamMusicPlayerComponent::CalculateWordProgress(FDreamMusicLyricTimestamp InCurrentTime, bool bUseRoma) const
{
	// è¾¹çæ£æ¥
	if (CurrentLyric.IsEmpty())
	{
		CachedCurrentWordIndex = -1;
		bCacheValid = false;
		return FDreamMusicLyricProgress(0, 0.0f, false, FDreamMusicLyricWord{});
	}

	// å¦æå½åæ¶é´å¨æ­è¯è¡å¼å§ä¹åï¼è¿å0
	if (InCurrentTime < CurrentLyric.StartTimestamp)
	{
		CachedCurrentWordIndex = -1;
		bCacheValid = false;
		return FDreamMusicLyricProgress(0, 0.0f, false, FDreamMusicLyricWord{});
	}

	// å¦æå½åæ¶é´å¨æ­è¯è¡ç»æä¹åï¼è¿å1ï¼å®æç¶æï¼
	if (InCurrentTime > CurrentLyric.EndTimestamp)
	{
		CachedCurrentWordIndex = -1;
		bCacheValid = false;
		return FDreamMusicLyricProgress(-1, 1.0f, false, FDreamMusicLyricWord{});
	}

	// å¦ææ²¡æåè¯æ¶é´ä¿¡æ¯ï¼ä½¿ç¨è¡è¿åº¦
	if (bUseRoma ? CurrentLyric.IsRomanizationWordsEmpty() : CurrentLyric.IsWordsEmpty())
	{
		return CalculateLineProgress(InCurrentTime);
	}

	// æå»ºç¼å­
	BuildWordDurationCache(bUseRoma);

	const TArray<FDreamMusicLyricWord>& Words = bUseRoma ? CurrentLyric.RomanizationWordTimings : CurrentLyric.WordTimings;

	// æ§è½ä¼åï¼ä»ä¸æ¬¡ä½ç½®å¼å§æ¥æ¾ï¼éå¸¸æ¶é´æ¯éå¢ç
	int32 StartIndex = 0;
	if (CachedCurrentWordIndex >= 0 && CachedCurrentWordIndex < Words.Num() &&
		InCurrentTime >= LastCalculationTime)
	{
		StartIndex = CachedCurrentWordIndex;
	}

	// æ¥æ¾å½ååè¯
	int32 CurrentWordIndex = -1;
	for (int32 i = StartIndex; i < Words.Num(); i++)
	{
		const FDreamMusicLyricWord& Word = Words[i];
		if (InCurrentTime >= Word.StartTimestamp && InCurrentTime < Word.EndTimestamp)
		{
			CurrentWordIndex = i;
			break;
		}
	}

	// å¦æä»ç¼å­ä½ç½®æ²¡æ¾å°ï¼ä»å¤´æ¥æ¾
	if (CurrentWordIndex == -1 && StartIndex > 0)
	{
		for (int32 i = 0; i < StartIndex; i++)
		{
			const FDreamMusicLyricWord& Word = Words[i];
			if (InCurrentTime >= Word.StartTimestamp && InCurrentTime < Word.EndTimestamp)
			{
				CurrentWordIndex = i;
				break;
			}
		}
	}

	// æ´æ°ç¼å­
	CachedCurrentWordIndex = CurrentWordIndex;
	LastCalculationTime = InCurrentTime;

	int32 LineTotalDuration = CurrentLyric.EndTimestamp.ToMilliseconds() - CurrentLyric.StartTimestamp.ToMilliseconds();

	if (CurrentWordIndex >= 0)
	{
		const FDreamMusicLyricWord& CurrentWord = Words[CurrentWordIndex];

		// ä½¿ç¨åç¼åå¿«éè®¡ç®è¿åº¦
		int32 ProgressToWordStart = (CurrentWordIndex > 0) ? WordDurationPrefixSum[CurrentWordIndex - 1] : 0;
		int32 CurrentWordElapsed = InCurrentTime.ToMilliseconds() - CurrentWord.StartTimestamp.ToMilliseconds();
		int32 TotalProgress = ProgressToWordStart + CurrentWordElapsed;

		float LineProgress = static_cast<float>(TotalProgress) / static_cast<float>(LineTotalDuration);

		return FDreamMusicLyricProgress(CurrentWordIndex, LineProgress, true, CurrentWord);
	}
	else
	{
		// åéå°è¡è¿åº¦è®¡ç®
		int32 Elapsed = InCurrentTime.ToMilliseconds() - CurrentLyric.StartTimestamp.ToMilliseconds();
		float LineProgress = static_cast<float>(Elapsed) / static_cast<float>(LineTotalDuration);

		return FDreamMusicLyricProgress(-1, LineProgress, false, FDreamMusicLyricWord{});
	}
}

FDreamMusicLyricProgress UDreamMusicPlayerComponent::CalculateLineProgress(FDreamMusicLyricTimestamp InCurrentTime) const
{
	if (InCurrentTime < CurrentLyric.StartTimestamp || InCurrentTime > CurrentLyric.EndTimestamp)
	{
		return FDreamMusicLyricProgress(-1, 0.0f, false, FDreamMusicLyricWord{});
	}

	int32 LineDuration = CurrentLyric.EndTimestamp.ToMilliseconds() - CurrentLyric.StartTimestamp.ToMilliseconds();
	int32 Elapsed = InCurrentTime.ToMilliseconds() - CurrentLyric.StartTimestamp.ToMilliseconds();
    
	// ä¿®å¤æ´æ°é¤æ³é®é¢
	float Progress = static_cast<float>(Elapsed) / static_cast<float>(LineDuration);
    
	return FDreamMusicLyricProgress(-1, Progress, false, FDreamMusicLyricWord{});
}

TArray<FString> UDreamMusicPlayerComponent::GetNames() const
{
	return UDreamMusicPlayerBlueprint::GetLyricFileNames();
}

void UDreamMusicPlayerComponent::StartMusic()
{
	if (!CurrentMusicData.IsVaild())
	{
		DMP_LOG(Error, TEXT("Current Music Data Is Not Valid !!!"))
		return;
	}

	// Clear any existing timers to prevent conflicts
	if (GWorld && GWorld->GetTimerManager().TimerExists(StopTimerHandle))
	{
		GWorld->GetTimerManager().ClearTimer(StopTimerHandle);
	}

	// Initialize State
	CurrentMusicDuration = 0.0f;
	CurrentMusicPercent = 0.0f;
	CurrentDuration = 0.0f;
	LastSeekPosition = 0.0f;
	MusicStartWorldTime = FPlatformTime::Seconds(); // è®°å½å¼å§æ¶é´
	bJustSeeked = false;
	CurrentTimestamp = FDreamMusicLyricTimestamp();

	// Switch audio components for seamless crossfading
	ToggleActiveAudioComponent();

	InitializeLyricList();

	// Validate SoundWave before playing
	if (!SoundWave || !SoundWave->IsValidLowLevel())
	{
		DMP_LOG(Error, TEXT("Invalid SoundWave for music: %s"), *CurrentMusicData.Information.Title);
		return;
	}

	// Set up audio component
	UAudioComponent* ActiveComponent = GetActiveAudioComponent();
	if (!ActiveComponent)
	{
		DMP_LOG(Error, TEXT("No valid audio component available"));
		return;
	}

	// Play Music with improved setup
	CurrentMusicDuration = SoundWave->Duration;
	ActiveComponent->SetSound(SoundWave);

	// Set volume to 0 before playing if fade-in is enabled
	if (FadeAudioSetting.bEnableFadeAudio && FadeAudioSetting.FadeInDuration > 0.0f)
	{
		ActiveComponent->SetVolumeMultiplier(0.0f);
	}

	ActiveComponent->Play();

	// Apply fade in
	if (FadeAudioSetting.bEnableFadeAudio && FadeAudioSetting.FadeInDuration > 0.0f)
	{
		ActiveComponent->FadeIn(FadeAudioSetting.FadeInDuration, 1.0f);
	}

	// Update state
	bIsPaused = false;
	bIsPlaying = true;
	SetPlayState(EDreamMusicPlayerPlayState::EDMPPS_Playing);

	// Callback
	OnMusicPlay.Broadcast(CurrentMusicData);
	DMP_LOG(Log, TEXT("Play Music : Name : %-15s Duration : %f"), *CurrentMusicData.Information.Title, CurrentMusicDuration);
}

void UDreamMusicPlayerComponent::EndMusic(bool Native)
{
	if (!bIsPlaying)
	{
		return; // Already stopped
	}

	UAudioComponent* ActiveComponent = GetActiveAudioComponent();
	if (!ActiveComponent)
	{
		DMP_LOG(Warning, TEXT("No active audio component to stop"));
		return;
	}

	// Clear any existing stop timer
	if (GWorld && GWorld->GetTimerManager().TimerExists(StopTimerHandle))
	{
		GWorld->GetTimerManager().ClearTimer(StopTimerHandle);
	}

	// Calculate fade out duration
	float FadeOutDuration = (FadeAudioSetting.bEnableFadeAudio && FadeAudioSetting.FadeOutDuration > 0.0f)
		                        ? FadeAudioSetting.FadeOutDuration
		                        : 0.0f;

	// Start fade out
	if (FadeOutDuration > 0.0f)
	{
		ActiveComponent->FadeOut(FadeOutDuration, 0.0f);

		// Schedule stop after fade completes
		if (GWorld)
		{
			GWorld->GetTimerManager().SetTimer(
				StopTimerHandle,
				[this, ActiveComponent]()
				{
					if (ActiveComponent && ActiveComponent->IsValidLowLevel())
					{
						ActiveComponent->Stop();
					}
				},
				FadeOutDuration,
				false
			);
		}
	}
	else
	{
		// Stop immediately if no fade
		ActiveComponent->Stop();
	}

	// Update state immediately
	bIsPaused = false;
	bIsPlaying = false;
	SetPlayState(EDreamMusicPlayerPlayState::EDMPPS_Stop);

	// Clean up state
	CurrentDuration = 0.0f;
	CurrentMusicDuration = 0.0f;
	CurrentMusicPercent = 0.0f;
	ConstantQDataL.Empty();
	ConstantQDataR.Empty();
	LoudnessValue = 0.0f;

	// Safely clear references
	ConstantQ = nullptr;
	Loudness = nullptr;

	// Cancel any pending theme color extraction
	if (CurrentKMeansTask && CurrentKMeansTask->IsValidLowLevel())
	{
		CurrentKMeansTask->Cancel();
		CurrentKMeansTask = nullptr;
	}

	OnMusicEnd.Broadcast();
	DMP_LOG(Log, TEXT("Music End : Name : %-15s Play Mode : %d"), *CurrentMusicData.Information.Title, (int)PlayMode);

	// Handle auto-play logic only if not manually stopped
	if (!Native)
	{
		// Add small delay to ensure clean transition
		if (GWorld)
		{
			GWorld->GetTimerManager().SetTimerForNextTick([this]()
			{
				HandleAutoPlayTransition();
			});
		}
	}
}

void UDreamMusicPlayerComponent::HandleAutoPlayTransition()
{
	if (!bIsPlaying) // Ensure we're still in stopped state
	{
		switch (PlayMode)
		{
		case EDreamMusicPlayerPlayMode::EDMPPS_Loop:
			if (CurrentMusicData.IsVaild())
			{
				SetMusicData(CurrentMusicData);
				StartMusic();
			}
			break;
		case EDreamMusicPlayerPlayMode::EDMPPS_Normal:
		case EDreamMusicPlayerPlayMode::EDMPPS_Random:
			PlayNextMusic();
			break;
		}
	}
}

void UDreamMusicPlayerComponent::PauseMusic()
{
	GetActiveAudioComponent()->SetPaused(true);
	SetPlayState(EDreamMusicPlayerPlayState::EDMPPS_Paused);
	bIsPaused = true;

	// æåæ¶ä¿å­å½åç²¾ç¡®æ¶é´ï¼åæ­¢ä¸çæ¶é´è®¡ç®
	CurrentDuration = GetAccuratePlayTime();
	LastSeekPosition = CurrentDuration;
	MusicStartWorldTime = 0.0; // åæ­¢ä¸çæ¶é´åºå

	OnMusicPause.Broadcast();
}

void UDreamMusicPlayerComponent::UnPauseMusic()
{
	GetActiveAudioComponent()->SetPaused(false);
	SetPlayState(EDreamMusicPlayerPlayState::EDMPPS_Playing);
	bIsPaused = false;

	// æ¢å¤æ­æ¾æ¶éæ°è®¾ç½®æ¶é´åºå
	MusicStartWorldTime = FPlatformTime::Seconds();
	bJustSeeked = true; // æ è®°ä¸ºåå Seekï¼ä½¿ç¨ä¿å­çä½ç½®

	OnMusicUnPause.Broadcast();
}

void UDreamMusicPlayerComponent::SetMusicData(FDreamMusicDataStruct InData)
{
	CurrentMusicData = InData;

	LoadAudioNrt();
	SoundWave = CurrentMusicData.Data.Music.LoadSynchronous();
	Cover = CurrentMusicData.Information.Cover.LoadSynchronous();

	if (bUseThemeColorExtension)
		ExtractCoverThemeColors(4, 10);

	OnMusicDataChanged.Broadcast(CurrentMusicData);
}

void UDreamMusicPlayerComponent::SetPlayState(EDreamMusicPlayerPlayState InState)
{
	PlayState = InState;
	OnPlayStateChanged.Broadcast(PlayState);
}

void UDreamMusicPlayerComponent::SetMusicPercent(float InPercent)
{
	if (!bIsPlaying || !GetActiveAudioComponent())
	{
		DMP_LOG(Warning, TEXT("Cannot set music percent when not playing or no active component"));
		return;
	}

	InPercent = FMath::Clamp(InPercent, 0.0f, 1.0f);
	CurrentMusicPercent = InPercent;

	// è®¡ç®ç®æ æ¶é´
	float TargetTime = CurrentMusicDuration * InPercent;
	CurrentDuration = TargetTime;
	LastSeekPosition = TargetTime;
	bJustSeeked = true;

	// éæ°è®¾ç½®å¼å§æ¶é´åºå
	MusicStartWorldTime = FPlatformTime::Seconds();

	// åºç¨æ­è¯åç§»
	float LyricTime = CurrentDuration + LyricOffset;
	CurrentTimestamp = *FDreamMusicLyricTimestamp().FromSeconds(LyricTime);

	// åæ­¢å¹¶éæ°å¼å§æ­æ¾
	UAudioComponent* ActiveComponent = GetActiveAudioComponent();
	bool WasPlaying = ActiveComponent->IsPlaying();

	if (WasPlaying)
	{
		ActiveComponent->Stop();
	}

	// ä»æ°ä½ç½®å¼å§æ­æ¾
	ActiveComponent->Play(TargetTime);

	// æ¢å¤æåç¶æ
	if (bIsPaused)
	{
		ActiveComponent->SetPaused(true);
		// æåæ¶ä¸æ´æ°ä¸çæ¶é´åºå
		MusicStartWorldTime = 0.0;
	}

	DMP_LOG(Log, TEXT("Set Music Percent: %.3f, Target Time: %.3f, Lyric Time: %.3f"),
	        CurrentMusicPercent, TargetTime, LyricTime);
}

void UDreamMusicPlayerComponent::SetMusicPercentFromTimestamp(FDreamMusicLyricTimestamp InTimestamp)
{
	SetMusicPercent(InTimestamp.ToSeconds() / CurrentMusicDuration);
}


void UDreamMusicPlayerComponent::SetCurrentLyric(FDreamMusicLyric InLyric)
{
	if (InLyric != CurrentLyric && InLyric.IsNotEmpty())
	{
		ClearLyricProgressCache();
		CurrentLyric = InLyric;
		OnLyricChanged.Broadcast(CurrentLyric, CurrentMusicLyricList.Find(CurrentLyric));
		DMP_LOG_DEBUG(Log, "Lyric", TEXT("Set : Time : %02d:%02d.%02d Content : %s"),
		              InLyric.StartTimestamp.Minute, InLyric.StartTimestamp.Seconds, InLyric.StartTimestamp.Millisecond, *InLyric.Content);
	}
}

void UDreamMusicPlayerComponent::LoadAudioNrt()
{
	if (CurrentMusicData.Data.ConstantQ.IsValid())
		ConstantQ = Cast<UConstantQNRT>(CurrentMusicData.Data.ConstantQ.TryLoad());
	if (CurrentMusicData.Data.Loudness.IsValid())
		Loudness = Cast<ULoudnessNRT>(CurrentMusicData.Data.Loudness.TryLoad());
	DMP_LOG(Log, TEXT("Load Audio NRT Done."))
}

void UDreamMusicPlayerComponent::MusicTick(float DeltaTime)
{
	// è·åæ´ç²¾ç¡®çæ­æ¾æ¶é´
	float AccuratePlayTime = GetAccuratePlayTime();

	// æ¹è¿çé³ä¹ç»ææ£æµ
	float EffectiveEndTime = CurrentMusicDuration;
	if (FadeAudioSetting.bEnableFadeAudio && FadeAudioSetting.FadeOutDuration > 0.0f)
	{
		EffectiveEndTime -= FadeAudioSetting.FadeOutDuration;
	}
	EffectiveEndTime -= 0.1f;

	if (AccuratePlayTime >= EffectiveEndTime)
	{
		DMP_LOG(Log, TEXT("Music Tick Music Name : %s - End"), *CurrentMusicData.Information.Title);
		EndMusic();
		return;
	}

	// æ´æ°æ¶é´ç¶æ
	CurrentDuration = AccuratePlayTime;
	CurrentMusicPercent = FMath::Clamp(CurrentDuration / CurrentMusicDuration, 0.0f, 1.0f);

	// åºç¨æ­è¯åç§»
	float LyricTime = CurrentDuration + LyricOffset;
	CurrentTimestamp = *FDreamMusicLyricTimestamp().FromSeconds(LyricTime);

	// è·åå½åæ­è¯ï¼ä½¿ç¨å¸¦åç§»çæ¶é´ï¼
	SetCurrentLyric(FDreamMusicPlayerLyricTools::GetLyricAtTimestamp(CurrentTimestamp, CurrentMusicLyricList));

	// æ´æ°é³é¢åææ°æ®
	UpdateAudioAnalysisData();

	OnMusicTick.Broadcast(CurrentDuration);

	// éç½® Seek æ å¿
	if (bJustSeeked)
	{
		bJustSeeked = false;
	}
}

bool UDreamMusicPlayerComponent::ToggleActiveAudioComponent()
{
	CurrentActiveAudioComponent = !CurrentActiveAudioComponent;
	DMP_LOG(Log, TEXT("Toggle Active Audio Component : %d"), CurrentActiveAudioComponent)
	return CurrentActiveAudioComponent;
}
